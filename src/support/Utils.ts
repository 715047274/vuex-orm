export type Iteretee = (value: any, key: string, collection: any) => any

export interface Dictionary<T> {
  [index: string]: T
}

export type Predicate<T> = (value: T, key: string) => boolean

/**
 * Check if the given object is empty.
 */
function isEmpty (data: any): boolean {
  if (Array.isArray(data)) {
    return data.length === 0
  }

  return Object.keys(data).length === 0
}

/**
 * Iterates over own enumerable string keyed properties of an object and
 * invokes `iteratee` for each property.
 */
export function forOwn (object: any, iteretee: Iteretee): void {
  Object.keys(object).forEach(key => iteretee(object[key], key, object))
}

/**
 * Create an array from the object.
 */
export function map (object: any, iteretee: Iteretee): any[] {
  return Object.keys(object).map((key) => {
    return iteretee(object[key], key, object)
  })
}

/**
 * Creates an object with the same keys as object and values generated by
 * running each own enumerable string keyed property of object thru
 * iteratee. The iteratee is invoked with three arguments:
 * (value, key, object).
 */
export function mapValues (object: any, iteretee: Iteretee): any {
  const newObject = Object.assign({}, object)

  return Object.keys(object).reduce((records, key) => {
    records[key] = iteretee(object[key], key, object)

    return records
  }, newObject)
}

/**
 * Creates an object composed of the object properties predicate returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 */
export function pickBy<T> (object: Dictionary<T>, predicate: Predicate<T>): Dictionary<T> {
  return Object.keys(object).reduce((records, key) => {
    const value = object[key]

    if (predicate(value, key)) {
      records[key] = value
    }

    return records
  }, {} as Dictionary<T>)
}

export default {
  isEmpty,
  forOwn,
  map,
  mapValues,
  pickBy
}
